// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.21.0
// source: repo_cleanup_jobs.sql

package store_queries

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const deleteRepoCleanupJob = `-- name: DeleteRepoCleanupJob :exec
DELETE FROM repo_cleanup_jobs
WHERE job_id = $1
`

func (q *Queries) DeleteRepoCleanupJob(ctx context.Context, jobID string) error {
	_, err := q.exec(ctx, q.deleteRepoCleanupJobStmt, deleteRepoCleanupJob, jobID)
	return err
}

const getCleanupJobsByRepo = `-- name: GetCleanupJobsByRepo :many
SELECT job_id, repo, refresh_token, cleanup_types, delete_older_than, num_deleted, num_deleted_today, est_num_remaining, job_state, created_at, updated_at, last_deleted_at
FROM repo_cleanup_jobs
WHERE repo = $1
ORDER BY updated_at DESC
LIMIT $2
`

type GetCleanupJobsByRepoParams struct {
	Repo  string `json:"repo"`
	Limit int32  `json:"limit"`
}

func (q *Queries) GetCleanupJobsByRepo(ctx context.Context, arg GetCleanupJobsByRepoParams) ([]RepoCleanupJob, error) {
	rows, err := q.query(ctx, q.getCleanupJobsByRepoStmt, getCleanupJobsByRepo, arg.Repo, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RepoCleanupJob
	for rows.Next() {
		var i RepoCleanupJob
		if err := rows.Scan(
			&i.JobID,
			&i.Repo,
			&i.RefreshToken,
			pq.Array(&i.CleanupTypes),
			&i.DeleteOlderThan,
			&i.NumDeleted,
			&i.NumDeletedToday,
			&i.EstNumRemaining,
			&i.JobState,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastDeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCleanupStats = `-- name: GetCleanupStats :one
SELECT SUM(num_deleted) AS total_num_deleted,
    COUNT (num_deleted) AS num_jobs,
    COUNT (DISTINCT repo) AS num_repos
FROM repo_cleanup_jobs
`

type GetCleanupStatsRow struct {
	TotalNumDeleted int64 `json:"total_num_deleted"`
	NumJobs         int64 `json:"num_jobs"`
	NumRepos        int64 `json:"num_repos"`
}

func (q *Queries) GetCleanupStats(ctx context.Context) (GetCleanupStatsRow, error) {
	row := q.queryRow(ctx, q.getCleanupStatsStmt, getCleanupStats)
	var i GetCleanupStatsRow
	err := row.Scan(&i.TotalNumDeleted, &i.NumJobs, &i.NumRepos)
	return i, err
}

const getRepoCleanupJob = `-- name: GetRepoCleanupJob :one
SELECT job_id, repo, refresh_token, cleanup_types, delete_older_than, num_deleted, num_deleted_today, est_num_remaining, job_state, created_at, updated_at, last_deleted_at
FROM repo_cleanup_jobs
WHERE job_id = $1
`

func (q *Queries) GetRepoCleanupJob(ctx context.Context, jobID string) (RepoCleanupJob, error) {
	row := q.queryRow(ctx, q.getRepoCleanupJobStmt, getRepoCleanupJob, jobID)
	var i RepoCleanupJob
	err := row.Scan(
		&i.JobID,
		&i.Repo,
		&i.RefreshToken,
		pq.Array(&i.CleanupTypes),
		&i.DeleteOlderThan,
		&i.NumDeleted,
		&i.NumDeletedToday,
		&i.EstNumRemaining,
		&i.JobState,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastDeletedAt,
	)
	return i, err
}

const getRunningCleanupJobs = `-- name: GetRunningCleanupJobs :many
SELECT job_id, repo, refresh_token, cleanup_types, delete_older_than, num_deleted, num_deleted_today, est_num_remaining, job_state, created_at, updated_at, last_deleted_at
FROM repo_cleanup_jobs
WHERE job_state = 'running'
ORDER BY updated_at ASC
LIMIT $1
`

func (q *Queries) GetRunningCleanupJobs(ctx context.Context, limit int32) ([]RepoCleanupJob, error) {
	rows, err := q.query(ctx, q.getRunningCleanupJobsStmt, getRunningCleanupJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RepoCleanupJob
	for rows.Next() {
		var i RepoCleanupJob
		if err := rows.Scan(
			&i.JobID,
			&i.Repo,
			&i.RefreshToken,
			pq.Array(&i.CleanupTypes),
			&i.DeleteOlderThan,
			&i.NumDeleted,
			&i.NumDeletedToday,
			&i.EstNumRemaining,
			&i.JobState,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastDeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRunningCleanupJobsByRepo = `-- name: GetRunningCleanupJobsByRepo :many
SELECT job_id, repo, refresh_token, cleanup_types, delete_older_than, num_deleted, num_deleted_today, est_num_remaining, job_state, created_at, updated_at, last_deleted_at
FROM repo_cleanup_jobs
WHERE repo = $1
    AND job_state = 'running'
ORDER BY updated_at DESC
`

func (q *Queries) GetRunningCleanupJobsByRepo(ctx context.Context, repo string) ([]RepoCleanupJob, error) {
	rows, err := q.query(ctx, q.getRunningCleanupJobsByRepoStmt, getRunningCleanupJobsByRepo, repo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RepoCleanupJob
	for rows.Next() {
		var i RepoCleanupJob
		if err := rows.Scan(
			&i.JobID,
			&i.Repo,
			&i.RefreshToken,
			pq.Array(&i.CleanupTypes),
			&i.DeleteOlderThan,
			&i.NumDeleted,
			&i.NumDeletedToday,
			&i.EstNumRemaining,
			&i.JobState,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastDeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertRepoCleanupJob = `-- name: UpsertRepoCleanupJob :one
INSERT INTO repo_cleanup_jobs (
        job_id,
        repo,
        refresh_token,
        cleanup_types,
        delete_older_than,
        num_deleted,
        num_deleted_today,
        est_num_remaining,
        job_state,
        updated_at,
        last_deleted_at
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) ON CONFLICT (job_id) DO
UPDATE
SET repo = $2,
    refresh_token = $3,
    cleanup_types = $4,
    delete_older_than = $5,
    num_deleted = $6,
    num_deleted_today = $7,
    est_num_remaining = $8,
    job_state = $9,
    updated_at = $10,
    last_deleted_at = $11
RETURNING job_id, repo, refresh_token, cleanup_types, delete_older_than, num_deleted, num_deleted_today, est_num_remaining, job_state, created_at, updated_at, last_deleted_at
`

type UpsertRepoCleanupJobParams struct {
	JobID           string       `json:"job_id"`
	Repo            string       `json:"repo"`
	RefreshToken    string       `json:"refresh_token"`
	CleanupTypes    []string     `json:"cleanup_types"`
	DeleteOlderThan time.Time    `json:"delete_older_than"`
	NumDeleted      int32        `json:"num_deleted"`
	NumDeletedToday int32        `json:"num_deleted_today"`
	EstNumRemaining int32        `json:"est_num_remaining"`
	JobState        string       `json:"job_state"`
	UpdatedAt       time.Time    `json:"updated_at"`
	LastDeletedAt   sql.NullTime `json:"last_deleted_at"`
}

// -- Repo Cleanup Jobs
// CREATE TABLE repo_cleanup_jobs (
//
//	job_id TEXT PRIMARY KEY,
//	repo TEXT NOT NULL,
//	refresh_token TEXT NOT NULL,
//	cleanup_types TEXT [] NOT NULL,
//	delete_older_than TIMESTAMP WITH TIME ZONE NOT NULL,
//	num_deleted INTEGER NOT NULL,
//	num_deleted_today INTEGER NOT NULL,
//	est_num_remaining INTEGER NOT NULL,
//	job_state TEXT NOT NULL,
//	created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
//	updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
//	last_deleted_at TIMESTAMP WITH TIME ZONE
//
// );
func (q *Queries) UpsertRepoCleanupJob(ctx context.Context, arg UpsertRepoCleanupJobParams) (RepoCleanupJob, error) {
	row := q.queryRow(ctx, q.upsertRepoCleanupJobStmt, upsertRepoCleanupJob,
		arg.JobID,
		arg.Repo,
		arg.RefreshToken,
		pq.Array(arg.CleanupTypes),
		arg.DeleteOlderThan,
		arg.NumDeleted,
		arg.NumDeletedToday,
		arg.EstNumRemaining,
		arg.JobState,
		arg.UpdatedAt,
		arg.LastDeletedAt,
	)
	var i RepoCleanupJob
	err := row.Scan(
		&i.JobID,
		&i.Repo,
		&i.RefreshToken,
		pq.Array(&i.CleanupTypes),
		&i.DeleteOlderThan,
		&i.NumDeleted,
		&i.NumDeletedToday,
		&i.EstNumRemaining,
		&i.JobState,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastDeletedAt,
	)
	return i, err
}
