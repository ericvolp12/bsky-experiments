// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: backfill.sql

package store_queries

import (
	"context"
	"time"
)

const createRepoBackfillRecord = `-- name: CreateRepoBackfillRecord :exec
INSERT INTO repo_backfill_status (
        repo,
        last_backfill,
        seq_started,
        state
    )
VALUES ($1, $2, $3, $4)
`

type CreateRepoBackfillRecordParams struct {
	Repo         string    `json:"repo"`
	LastBackfill time.Time `json:"last_backfill"`
	SeqStarted   int64     `json:"seq_started"`
	State        string    `json:"state"`
}

// Backfill Status
// CREATE TABLE repo_backfill_status (
//
//	repo TEXT NOT NULL,
//	last_backfill TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP NOT NULL,
//	seq_started BIGINT DEFAULT 0 NOT NULL,
//	state TEXT DEFAULT 'in_progress'::text NOT NULL,
//	PRIMARY KEY (repo)
//
// );
func (q *Queries) CreateRepoBackfillRecord(ctx context.Context, arg CreateRepoBackfillRecordParams) error {
	_, err := q.exec(ctx, q.createRepoBackfillRecordStmt, createRepoBackfillRecord,
		arg.Repo,
		arg.LastBackfill,
		arg.SeqStarted,
		arg.State,
	)
	return err
}

const getRepoBackfillRecord = `-- name: GetRepoBackfillRecord :one
SELECT repo, last_backfill, seq_started, state
FROM repo_backfill_status
WHERE repo = $1
`

func (q *Queries) GetRepoBackfillRecord(ctx context.Context, repo string) (RepoBackfillStatus, error) {
	row := q.queryRow(ctx, q.getRepoBackfillRecordStmt, getRepoBackfillRecord, repo)
	var i RepoBackfillStatus
	err := row.Scan(
		&i.Repo,
		&i.LastBackfill,
		&i.SeqStarted,
		&i.State,
	)
	return i, err
}

const getRepoBackfillRecords = `-- name: GetRepoBackfillRecords :many
SELECT repo, last_backfill, seq_started, state
FROM repo_backfill_status
ORDER BY last_backfill ASC
LIMIT $1 OFFSET $2
`

type GetRepoBackfillRecordsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetRepoBackfillRecords(ctx context.Context, arg GetRepoBackfillRecordsParams) ([]RepoBackfillStatus, error) {
	rows, err := q.query(ctx, q.getRepoBackfillRecordsStmt, getRepoBackfillRecords, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RepoBackfillStatus
	for rows.Next() {
		var i RepoBackfillStatus
		if err := rows.Scan(
			&i.Repo,
			&i.LastBackfill,
			&i.SeqStarted,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRepoBackfillRecord = `-- name: UpdateRepoBackfillRecord :exec
UPDATE repo_backfill_status
SET last_backfill = $2,
    seq_started = $3,
    state = $4
WHERE repo = $1
`

type UpdateRepoBackfillRecordParams struct {
	Repo         string    `json:"repo"`
	LastBackfill time.Time `json:"last_backfill"`
	SeqStarted   int64     `json:"seq_started"`
	State        string    `json:"state"`
}

func (q *Queries) UpdateRepoBackfillRecord(ctx context.Context, arg UpdateRepoBackfillRecordParams) error {
	_, err := q.exec(ctx, q.updateRepoBackfillRecordStmt, updateRepoBackfillRecord,
		arg.Repo,
		arg.LastBackfill,
		arg.SeqStarted,
		arg.State,
	)
	return err
}
